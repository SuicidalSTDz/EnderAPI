{"name":"EnderAPI","tagline":"An API by the people, for the people","body":"## Developement Team\r\n<a href=\"https://github.com/SuicidalSTDz\">SuicidalSTDz</a> - Lead Developer <br>\r\n<a href=\"https://github.com/apemanzilla\">apemanzilla</a> - Developer <br>\r\n<a href=\"https://github.com/skwerlman\">skwerlman</a> - Developer <br>\r\n<a href=\"https://github.com/EngineerCoding\">EngineerCoding</a> - Developer <br>\r\n<a href=\"https://github.com/KingofGamesYami\">KingofGamesYami</a> - Developer <br>\r\n\r\n## Accepted Suggestions\r\n* Graph API\r\n* Better Parallel API\r\n* Better Turtle API\r\n* Terminal Screenshot API (An add-on to the native term API)\r\n* Prompt API (By KingofGamesYami)\r\n\r\n## Colors API Extension\r\n### colors.convertToString( nColor )\r\n```Lua\r\nfunction colors.convertToString( nColor )\r\n  for k, v in pairs( colors ) do\r\n    if nColor == v then\r\n      return k\r\n    end\r\n  end\r\n  return nil\r\nend\r\n```\r\n* Converts nColor to it's english string. For instance, colors.convertToString( 1 ) will return \"white\"\r\n* Returns color _[string]_\r\n\r\n## Fs API Extension\r\n### fs.append( sPath, sData )\r\n```Lua\r\nfunction fs.append( sPath, sData )\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2 )\r\n  assert( type( sData ) == \"string\", \"String expected, got \" .. type( sData ), 2 )\r\n  local f\r\n  if not fs.exists(sPath) then\r\n    f = fs.open( sPath, \"w\" )\r\n  else\r\n    f = fs.open( sPath, \"a\" )\r\n  end\r\n  f.write( sData )\r\n  f.close()\r\nend\r\n```\r\n* Appends sData to sPath\r\n* Returns: _[nil]_\r\n\r\n### fs.read( sPath )\r\n```Lua\r\nfunction fs.read( sPath )\r\n  assert( type( sPath ) == \"string\", \"string expected, got \" .. type( sPath ), 2 )\r\n  if fs.exists(sPath) then\r\n    local handle = fs.open( sPath, \"r\" )\r\n    local sData = handle.readAll()\r\n    handle.close()\r\n    return sData, true\r\n  end\r\n  return nil, false\r\nend\r\n```\r\n* Returns sPath's contents\r\n* Returns: contents [_string_], success [_boolean_]\r\n\r\n### fs.save( sPath, sData )\r\n```Lua\r\nfunction fs.save( sPath, sData )\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2 )\r\n  assert( type( sData ) == \"string\", \"String expected, got \" .. type( sData ), 2 )\r\n  local f = fs.open( sPath, \"w\" )\r\n  f.write( sData )\r\n  f.close()\r\nend\r\n```\r\n* Saves sData to sPath ( overwrites current file )\r\n* Returns: [_nil_]\r\n\r\n## HTTP API\r\n###http.download( sUrl, sPath )\r\n```Lua\r\nfunction http.download( sUrl, sPath )\r\n  assert( type( sUrl ) == \"string\", \"String expected, got \" .. type( sUrl ), 2)\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2)\r\n  assert( not fs.exists( sPath ), \"Path already exists\", 2)\r\n  \r\n  local response = http.get( sUrl )\r\n  if response then\r\n    local f = fs.open( sPath, \"w\" )\r\n    f.write( response.readAll() )\r\n    f.close()\r\n    response.close()\r\n    return true\r\n  end\r\n  return false\r\nend\r\n```\r\n* Downloads the given sUrl in sPath\r\n* Returns: success [_boolean_]\r\n\r\n## MessageBox API\r\n* Deprecated, for now [-STDz]\r\n\r\n## Number API\r\n### number.generate( nLength, nMin, nMax )\r\n```Lua\r\nfunction generate( nLength, nMin, nMax )\r\n  assert( type( nLength ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( nMins ) == \"number\", \"Number expected, got \" .. type( nMin ), 2)\r\n  assert( type( nMax ) == \"number\", \"Number expected, got \" .. type( nMax ), 2)\r\n  assert( nMin < nMax, \"Minimum must be less than maximum\", 2)\r\n\r\n  local n = math.random( nMin, nMax )\r\n  for i = 1, nLength do\r\n    n = n .. math.random( nMin, nMax )\r\n  end\r\n  return tonumber( n )\r\nend\r\n```\r\n* Generates a number of nLength with values ranging from nMin to nMax\r\n* Returns: [_number_]\r\n\r\n### number.isOdd( n )\r\n```Lua\r\nfunction isOdd( n )\r\n  assert( type( n ) == \"number\", \"Number expected, got \" .. type( n ), 2)\r\n  return n % 2 ~= 0\r\nend\r\n```\r\n* Returns whether or not n is an odd number\r\n* Returns: [_boolean_]\r\n\r\n### number.isEven( n )\r\n```Lua\r\nfunction isEven( n )\r\n  assert( type( n ) == \"number\", \"Number expected, got \" .. type( n ), 2)\r\n  return n % 2 == 0\r\nend\r\n```\r\n* Returns whether or not n is an even number\r\n* Returns [_boolean_]\r\n\r\n## Pastebin API\r\n### pastebin.get( sCode, sFile )\r\n```Lua\r\nfunction get( sCode, sFile )\r\n  assert( type( sCode ) == \"string\", \"Number expected, got \" .. type( sCode ), 2)\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.exists( sPath ), \"File exists\", 2)\r\n\r\n  local tResponse = http.get( \"http://pastebin.com/raw.php?i=\" .. textutils.urlEncode( sCode ) )\r\n  if tResponse then\r\n    local sResponse = tResponse.readAll()\r\n    tResponse.close()\r\n    \r\n    local handle = fs.open( sPath, \"w\" )\r\n    handle.write( sResponse )\r\n    handle.close()\r\n    return true\r\n  end\r\n  return false\r\nend\r\n```\r\n* Downloads sCode from pastebin as sFile\r\n* Returns: success [_boolean_]\r\n\r\n### pastebin.put( sFile )\r\n```Lua\r\nfunction put( sFile )\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  \r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.isDir( sPath ), \"Cannot upload directories\", 2 )\r\n  assert( not fs.exists( sPath ), \"File doesn't exist\", 2 )\r\n  \r\n  local sName = fs.getName( sPath )\r\n  local handle = fs.open( sPath, \"r\" )\r\n  local sText = handle.readAll()\r\n  handle.close()\r\n  local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\r\n  local response = http.post(\r\n    \"http://pastebin.com/api/api_post.php\", \r\n    \"api_option=paste&\" ..\r\n    \"api_dev_key=\" .. key .. \"&\" ..\r\n    \"api_paste_format=lua&\" ..\r\n    \"api_paste_name=\" .. textutils.urlEncode( sPath ) .. \"&\" ..\r\n    \"api_paste_code=\" .. textutils.urlEncode( sText )\r\n  )\r\n\r\n  if response then\r\n    local sResponse = response.readAll()\r\n    local sCode = string.match( sResponse, \"[^/]+$\" )\r\n    response.close()\r\n    return sCode, true\r\n  end\r\n  return nil, false\r\nend\r\n```\r\n* Uploads sFile to pastebin\r\n* Returns: code [_string_], success [_boolean_]\r\n\r\n### pastebin.updateFile( sCode, sFile )\r\n```Lua\r\nfunction updateFile( sCode, sFile )\r\n  assert( type( sCode ) == \"string\", \"Number expected, got \" .. type( sCode ), 2)\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  \r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.isDirectory( sPath ), \"Cannot update directory\", 2)\r\n  \r\n  local httpHandle = http.get( \"http://pastebin.com/raw.php?i=\" .. textutils.urlEncode( sCode ) )\r\n  if httpHandle then\r\n    local sResponse = httpHandle.readAll()\r\n    httpHandle.close()\r\n    \r\n    if sResponse and sResponse ~= \"\" then\r\n      local fileContent = \"[none&set]\"\r\n      if fs.exists( sPath ) then\r\n        local fileHandle = fs.open( sPath, \"r\" )\r\n        fileContent = fileHandle.readAll()\r\n        fileHandle.close()\r\n      end\r\n        \r\n      if fileContent ~= sResponse then\r\n        fileHandle = fs.open( sPath, \"w\" )\r\n        fileHandle.write( sResponse )\r\n        fileHandle.close()\r\n        return true\r\n      end\r\n    end\r\n    return false\r\nend\r\n```\r\n* Updates sFile using sCode from pastebin, if sFile is not the same as pastebin file\r\n* Returns: success [_boolean_]\r\n\r\n## String API\r\n### string.generate( nLength, nCharSet )\r\n```Lua\r\nfunction string.generate( nLength, nCharSet )\r\n  assert( type( nLength ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( nCharSet ) == \"number\", \"Number expected, got \" .. type( nCharSet ), 2)\r\n\tlocal nCharSet = nCharSet or 128\r\n\tlocal str = \"\"\r\n\tfor i = 1, nLength do\r\n\t\tstr = str .. math.random( 1, nCharSet ):char()\r\n\tend\r\n\treturn str\r\nend\r\n```\r\n* Generates a string of nLength with ASCII characters ranging from 0 to nCharSet (or, by default, 128)\r\n* Returns: [_string_]\r\n\r\n### string.replaceChar( str, nPos, sReplace ) OR string:replaceChar( nPos, sReplace )\r\n```Lua\r\nfunction string:replaceChar( nPos, sReplace )\r\n  assert( type( nPos ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( sReplace ) == \"string\", \"String expected, got \" .. type( nCharSet ), 2)\r\n  return self:sub( 1, nPos - 1 ) .. sReplace .. self:sub( nPos + 1 )\r\nend\r\n```\r\n* Replaces character at nPos in string with sReplace\r\n* Returns: [_string_]\r\n\r\n###string.safePattern()\r\n```Lua\r\nTo be completed\r\n```\r\n( Insert description here )\r\n\r\n###string.splitAtWhite( str )\r\n```Lua\r\nfunction string:splitAtWhite()\r\n\tlocal tData = {}\r\n\tfor sArg in self:gmatch( \"[^%s]+\" ) do\r\n\t\ttable.insert( tData, sArg )\r\n\tend\r\n\treturn tData\r\nend\r\n```\r\n* Splits str into seperate elements based on whitespace. Good for pulling arguments from a single string\r\n* Returns: [_table_]\r\n\r\n## Table API\r\n### table.sortLToG( tbl )\r\n```Lua\r\nfunction table.sortLToG( tbl )\r\n  assert( type( tbl ) == \"table\", \"Table expected, got \" .. type( tbl ), 2 )\r\n  table.sort( tbl, function( a, b ) return a < b end )\r\n  return tbl\r\nend\r\n```\r\n* Sorts tbl's elements from least to greatest( A - Z, 1 - 9, etc )\r\n* Returns: [_table_]\r\n\r\n### table.sortGToL( tbl )\r\n```Lua\r\nfunction table.sortGToL( tbl )\r\n  table.sort( tbl, function( a, b ) return a > b end )\r\n  return tbl\r\nend\r\n```\r\n* Sorts tbl's elements from greatest to least ( Z - A, 9 - 1, etc )\r\n* Returns: [_table_]\r\n\r\n## Term API\r\n### term.getCursorBlink()\r\n```Lua\r\nTo be completed\r\n```\r\n( Insert description here )\r\n\r\n### term.clear( nx, ny, nTextColour, nBackgroundColour )\r\n```Lua\r\nfunction term.clear( nx, ny, nTextColour, nBackgroundColour )\r\n  if nTextColour ~= nil then\r\n    assert( type( nTextColour ) == \"number\", \"Number expected, got \" .. type( nTextColour ), 2)\r\n    term.setTextColour( nTextColour )\r\n  end\r\n  if nBackgroundColour ~= nil then\r\n    assert( type( nBackgroundColour ) == \"number\", \"Number expected, got \" .. type( nBackgroundColour ), 2)\r\n    term.setBackgroundColour( nBackgroundColour )\r\n  end\r\n  if nx ~= nil then\r\n    assert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  end\r\n  if ny ~= nil then\r\n    assert( type( ny ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  end\r\n  term.setCursorPos( nx or currentX, ny or currentY )\r\n  oldTerm.clear()\r\n  local nMaxx,nMaxy = term.getSize()\r\n  -- Clear pixel data\r\n  for i = 1, nMaxx do\r\n    for j = 1, nMaxy do\r\n      tPixels[i..\" \"..j] = {\r\n        Character = \" \",\r\n        TextColor = nTextColour or term.getTextColour(),\r\n        TextColour = nTextColour or term.getTextColour(),\r\n        BackgroundColor = nBackgroundColour or term.getBackgroundColour(),\r\n        BackgroundColour = nBackgroundColour or term.getBackgroundColour()\r\n      }\r\n    end\r\n  end\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.reset()\r\n```Lua\r\nfunction term.reset()\r\n  term.setTextColour(colors.white)\r\n  term.setBackgroundColour(colors.black)\r\n  term.setCursorPos(1,1)\r\n  term.setCursorBlink(false)\r\n  term.clear()\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.getPixelData( nx, ny )\r\n```Lua\r\nfunction term.getPixelData( nx, ny )\r\n  assert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  assert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n  return tPixels[ nx .. \" \" .. ny ]\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.getTextColor()\r\n```Lua\r\nfunction term.getTextColor()\r\n  return currentTextColour\r\nend\r\n```\r\n* Returns the current terminal's text color\r\n* Returns: color [_number_]\r\n\r\n### term.getBackgroundColour()\r\n```Lua\r\nfunction term.getBackgroundColour()\r\n  return currentBackgroundColour\r\nend\r\n```\r\n* Returns the current terminal's background color\r\n* Returns: color [_number_]\r\n\r\n## Text API\r\n### text.bracket( sText, nx, ny, nTextColour, nBracketColour, nBackgroundColour )\r\n```Lua\r\nfunction bracket( sText, nx, ny, nTextColour, nBracketColour, nBackgroundColour )\r\n\tassert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n\tassert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n\tassert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n\r\n  if nTextColour then\r\n    assert( type( nTextColour ) == \"number\", \"Number/nil expected, got \" .. type( nTextColour ), 2)\r\n  end\r\n  if nBracketColour then\r\n    assert( type( nBracketColour ) == \"number\", \"Number/nil expected, got \" .. type( nBracketColour ), 2)\r\n  end\r\n  if nBackgroundColour then\r\n\t\tassert( type( nBackgroundColour ) == \"number\", \"Number/nil expected, got \" .. type( nBackgroundColour ), 2)\r\n    term.setBackgroundColour( nBackgroundColour )\r\n\tend\r\n  \r\n\tlocal xPos, yPos = term.getCursorPos()\r\n\tterm.setCursorPos( nx, ny )\r\n\tterm.setTextColour( nBracketColour or colours.white )\r\n\tterm.write( \"[\" .. string.rep(\" \", #sText) .. \"]\" )\r\n  \r\n\tterm.setTextColour( nTextColour or colours.white )\r\n  term.setCursorPos( nx + 1, ny )\r\n\tterm.write( sText )\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## text.center( sText, nx, ny )\r\n```Lua\r\nfunction center( sText, nx, ny )\r\n\tassert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n\tassert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n\tassert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n\tterm.setCursorPos( (( nx - #sText ) / 2) - 1, ny )\r\n\tterm.write( sText )\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## text.printColorFormat( sText )\r\n```Lua\r\nfunction printColourFormat( sText )\r\n  assert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n  local char200 = string.char( 200 )\r\n  \r\n  local storage = {}\r\n  local function matchLong( sMode1, sColour1, sMode2, sColour2 )\r\n    if (sMode1 == \"t\" and sMode2 == \"b\") or (sMode1 == \"b\" and sMode2 == \"t\") then\r\n      table.insert( storage, { \r\n        t = ( sMode1 == \"t\" and tonumber( sColour1 ) or tonumber( sColour2 ) ),\r\n        b = ( sMode1 == \"b\" and tonumber( sColour1 ) or tonumber( sColour2 ) )\r\n      } )\r\n    end\r\n    \r\n    if sMode1 == \"b\" and sMode2 == \"b\" then\r\n      table.insert( storage, { b = tonumber( sColour2 ) } )\r\n    elseif sMode1 == \"t\" and sMode2 == \"t\" then\r\n      table.insert( storage, { t = tonumber( sColour2 ) } )\r\n    end\r\n    return char200\r\n  end\r\n  \r\n  local function matchShort( sMode, sColour ) \r\n    return matchLong( sMode, sColour, sMode, sColour )\r\n  end\r\n  \r\n  -- Parse the text\r\n  local parsed = sText:gsub( \"%[([bt])%s*=%s*(%d-);%s*([bt])%s*=%s*(%d-)%]\", matchLong )\r\n  parsed = parsed:gsub( \"%[([bt])%s*=%s*(%d-)%]\", matchShort )\r\n  \r\n  -- Print it out on the terminal\r\n  local index = 1\r\n  local sMatch = \"[^\" .. char200 .. \"]+\"\r\n  for i = 1, #parsed do\r\n    local char = parsed:sub( i, i )\r\n    if storage[index] and char == char200 then\r\n      if storage[index].t then\r\n        term.setTextColour( 2 ^ storage[index].t )\r\n      end\r\n      if storage[index].b then\r\n        term.setBackgroundColour( 2 ^ storage[index].b )\r\n      end\r\n      index = index + 1\r\n    else\r\n       write( char )\r\n    end\r\n  end\r\nend\r\n```\r\n( Insert description here )","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}