{"name":"EnderAPI","tagline":"An API by the people, for the people","body":"## Developement Team\r\n<a href=\"https://github.com/SuicidalSTDz\">SuicidalSTDz</a> - Lead Developer <br>\r\n<a href=\"https://github.com/apemanzilla\">apemanzilla</a> - Developer <br>\r\n<a href=\"https://github.com/skwerlman\">skwerlman</a> - Developer <br>\r\n<a href=\"https://github.com/EngineerCoding\">EngineerCoding</a> - Developer <br>\r\n\r\n## Accepted Suggestions\r\n* Graph API\r\n* Better Parallel API\r\n* Better Turtle API\r\n* Debugging API\r\n* Terminal Screenshot API (An add-on to the native term API)\r\n* Prompt API (By KingofGamesYami)\r\n\r\n## Colors API\r\n### colors.convertToString( nColor )\r\n```Lua\r\nfunction colors.convertToString( nColor )\r\n  for k, v in pairs( colors ) do\r\n    if nColor == v then\r\n      return k\r\n    end\r\n  end\r\n  return nil\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## Fs API\r\n### fs.append( sPath, sData )\r\n```Lua\r\nfunction fs.append( sPath, sData )\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2 )\r\n  assert( type( sData ) == \"string\", \"String expected, got \" .. type( sData ), 2 )\r\n  local f\r\n  if not fs.exists(sPath) then\r\n    f = fs.open( sPath, \"w\" )\r\n  else\r\n    f = fs.open( sPath, \"a\" )\r\n  end\r\n  f.write( sData )\r\n  f.close()\r\nend\r\n```\r\n* Appends sData to sPath\r\n* Returns: _nil_\r\n\r\n### fs.read( sPath )\r\n```Lua\r\nfunction fs.read( sPath )\r\n  assert( type( sPath ) == \"string\", \"string expected, got \" .. type( sPath ), 2 )\r\n  if fs.exists(sPath) then\r\n    local handle = fs.open( sPath, \"r\" )\r\n    local sData = handle.readAll()\r\n    handle.close()\r\n    return sData, true\r\n  end\r\n  return nil, false\r\nend\r\n```\r\n* Returns sPath's contents\r\n* Returns: contents _string_, success _boolean_\r\n\r\n### fs.save( sPath, sData )\r\n```Lua\r\nfunction fs.save( sPath, sData )\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2 )\r\n  assert( type( sData ) == \"string\", \"String expected, got \" .. type( sData ), 2 )\r\n  local f = fs.open( sPath, \"w\" )\r\n  f.write( sData )\r\n  f.close()\r\nend\r\n```\r\n* Saves sData to sPath ( overwrites current file )\r\n* Returns: _nil_\r\n\r\n## HTTP API\r\n###http.download( sUrl, sPath )\r\n```Lua\r\nfunction http.download( sUrl, sPath )\r\n  assert( type( sUrl ) == \"string\", \"String expected, got \" .. type( sUrl ), 2)\r\n  assert( type( sPath ) == \"string\", \"String expected, got \" .. type( sPath ), 2)\r\n  assert( not fs.exists( sPath ), \"Path already exists\", 2)\r\n  \r\n  local response = http.get( sUrl )\r\n  if response then\r\n    local f = fs.open( sPath, \"w\" )\r\n    f.write( response.readAll() )\r\n    f.close()\r\n    response.close()\r\n    return true\r\n  end\r\n  return false\r\nend\r\n```\r\n* Downloads the given sUrl in sPath\r\n* Returns: success _boolean_\r\n\r\n## MessageBox API\r\n###messageBox.create( sText, fYes, fNo )\r\nWARNING: Probably very unappealing but don't complain. I am working on it <br>\r\n```Lua\r\nlocal function assert(bBool, sMessage, nLevel)\r\n  nLevel = nLevel or -1 -- Changing the value of a param doesn't affect its scope, so local isn't necessary. (confirmed by eclipse)\r\n  if type(sMessage) ~= \"string\" then\r\n    error(\"String expected, got \" .. type( sMessage ), 2)\r\n  elseif type(nLevel) ~= \"number\" then\r\n    error(\"Number expected, got \" .. type( nLevel ), 2)\r\n  end\r\n  \r\n  if not bBool then\r\n    error( sMessage, nLevel + 1 ) -- should be nLevel; iLevel was a typo\r\n  end\r\n  return bBool\r\nend\r\n\r\nlocal function getContainer( obj, env, tIgnore, bGlobal ) -- a nifty little function that finds the name of the variable holding its first param in the environment provided by env, and ignores all variables with names matching those in tIgnore. It will scan _G if bGlobal == true and the variable is not in env\r\n  if not tIgnore then\r\n    tIgnore = {}\r\n  end\r\n  bGlobal = bGlobal or false\r\n  if type( tIgnore ) ~= 'table' then\r\n    tIgnore = { tIgnore }\r\n  end\r\n  table.insert( tIgnore, 'obj' )\r\n  for k, v in pairs(env) do -- Check the provided environment\r\n    local shouldIgnore = false\r\n    for i=1, #tIgnore do\r\n      if tIgnore[i] == k then\r\n        shouldIgnore = true\r\n      end\r\n    end\r\n    if v == obj and not shouldIgnore then\r\n      return k -- Return as soon as we find it\r\n    end\r\n  end\r\n  if bGlobal then -- scan _G, if we haven't found it yet\r\n    for k, v in pairs(_G) do\r\n      local shouldIgnore = false\r\n      for i=1, #tIgnore do\r\n        if tIgnore[i] == k then\r\n          shouldIgnore = true\r\n        end\r\n      end\r\n      if v == obj and not shouldIgnore then\r\n        return k\r\n      end\r\n    end\r\n  end\r\n  return '? (a local '..type( obj )..')' -- Return a value similar in format to those provided for native errors if we couldn't find the object's name.\r\nend\r\n\r\nfunction create( sText, nBorderColour, nInnerColour, fYes, fNo )\r\n  assert( type( sText ) == \"string\", \"String expected, got \".. type( sText ), 2)\r\n  assert( type( fYes ) == \"function\", \"Function expected, got \".. type( fYes ), 2)\r\n  assert( type( fNo ) == \"function\", \"Function expected, got \".. type( fNo ), 2)\r\n  \r\n  if not text then\r\n    error( \"The Text API must be installed to use this function\", 2 )\r\n  end\r\n  if not term.enderAPI then -- We're also dependent on our term extensions, although no one noticed\r\n    error( \"The EnderAPI term extension must be enabled to use this function\", 2 )\r\n  end\r\n  \r\n  local nw, nh = term.getSize()\r\n  local startX = math.floor( ( ( nw - #sText ) / 2 ) - 5 )\r\n  local startY = math.floor( nh / 2 - 3 )\r\n  local endX = math.floor( ( ( nw + #sText ) / 2 ) + 7 )\r\n  local endY = math.floor( nh / 2 + 4 )\r\n  local nMiddle = math.floor( ( endX + startX ) / 2 )\r\n  local tOverwrite = {}\r\n  \r\n  --# The two line below this were compacted. term.getCursorPos returns two values which can be put directly into a table, instead of asigning them manually\r\n  local tCursorPos = { term.getCursorPos() }\r\n  --tCursorPos[1], tCursorPos[2] = term.getCursorPos() -- Save where the cursor was so we can put it back later\r\n  \r\n  for ny = startY, endY do\r\n    for nx = startX, endX do\r\n      tOverwrite[ nx .. \" \" .. ny ] = term.getPixelData( nx, ny )\r\n    end\r\n  end\r\n  \r\n  paintutils.drawLine( startX, startY, endX, startY, nBorderColour )\r\n  paintutils.drawLine( startX, startY, startX, endY, nBorderColour )\r\n  paintutils.drawLine( endX, startY, endX, endY, nBorderColour )\r\n  paintutils.drawLine( startX, endY, endX, endY, nBorderColour )\r\n  for ny = startY + 1, endY - 1 do\r\n    paintutils.drawLine( startX + 1, ny, endX - 1, ny, nInnerColour )\r\n  end\r\n  text.bracket( \"Yes\", math.floor( ( ( startX + nMiddle ) / 2 ) - 2 ), endY - 2, colours.red, colours.white, nInnerColour ) -- Shouldn't we be using 'color' instead of 'colour'? 'color' takes up less space on the computer and is a microscopic amount faster, and there's no change in functionality\r\n  text.bracket( \"No\", math.floor( ( endX + nMiddle ) / 2 ), endY - 2, colours.red, colours.white, nInnerColour )\r\n  term.setCursorPos( nMiddle - ( #sText / 2 ), startY + 2 )\r\n  term.write( sText )\r\n  \r\n  local sEvent, nButton, xPos, yPos, fSelection\r\n  while true do\r\n    sEvent, nButton, xPos, yPos = os.pullEvent( \"mouse_click\" )\r\n    \r\n    if nButton == 1 then\r\n      if yPos == endY - 2 then\r\n        if ( xPos >= math.floor( ( startX + nMiddle ) / 2 - 3 ) and xPos <= math.floor( ( startX + nMiddle ) / 2 - 3 ) + 4 ) then\r\n          local ok, err = pcall( fYes )\r\n          fSelection = fYes\r\n          break\r\n        elseif ( xPos >= math.floor( ( endX + nMiddle ) / 2 ) and xPos <= math.floor( ( endX + nMiddle ) / 2 ) + 3 ) then\r\n          fSelection = fNo\r\n          break\r\n        end\r\n      end -- Fixed errant tabs; use tabs OR spaces, not both\r\n    end\r\n  end\r\n  \r\n  for ny = startY, endY do -- Moved this loop to execute before the response functions; prevents odd behavior\r\n    for nx = startX, endX do\r\n      term.setTextColour( tOverwrite[ nx .. \" \" .. ny ].TextColour )\r\n      term.setBackgroundColour( tOverwrite[ nx .. \" \" .. ny ].BackgroundColour )\r\n      term.setCursorPos( nx, ny )\r\n      term.write( tOverwrite[ nx .. \" \" .. ny ].Character )\r\n    end\r\n  end\r\n  term.setCursorPos(unpack(tCursorPos))\r\n  \r\n  local ok, err = pcall( fSelection )\r\n  if not ok then\r\n    error( \"Could not invoke \"..getContainer(fSelection, getfenv(2), { 'fNo', 'fYes', 'fSelection' }), 2 )\r\n  end\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## Number API\r\n### number.generate( nLength, nMin, nMax )\r\n```Lua\r\nfunction generate( nLength, nMin, nMax )\r\n  assert( type( nLength ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( nMins ) == \"number\", \"Number expected, got \" .. type( nMin ), 2)\r\n  assert( type( nMax ) == \"number\", \"Number expected, got \" .. type( nMax ), 2)\r\n  assert( nMin < nMax, \"Minimum must be less than maximum\", 2)\r\n\r\n  local n = math.random( nMin, nMax )\r\n  for i = 1, nLength do\r\n    n = n .. math.random( nMin, nMax )\r\n  end\r\n  return tonumber( n )\r\nend\r\n```\r\n* Generates a number of nLength with values ranging from nMin to nMax\r\n* Returns: _number_\r\n\r\n### number.isOdd( n )\r\n```Lua\r\nfunction isOdd( n )\r\n  assert( type( n ) == \"number\", \"Number expected, got \" .. type( n ), 2)\r\n  return n % 2 ~= 0\r\nend\r\n```\r\n* Returns whether or not n is an odd number\r\n* Returns: _boolean_\r\n\r\n### number.isEven( n )\r\n```Lua\r\nfunction isEven( n )\r\n  assert( type( n ) == \"number\", \"Number expected, got \" .. type( n ), 2)\r\n  return n % 2 == 0\r\nend\r\n```\r\n* Returns whether or not n is an even number\r\n* Returns _boolean_\r\n\r\n## Pastebin API\r\n### pastebin.get( sCode, sFile )\r\n```Lua\r\nfunction get( sCode, sFile )\r\n  assert( type( sCode ) == \"string\", \"Number expected, got \" .. type( sCode ), 2)\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.exists( sPath ), \"File exists\", 2)\r\n\r\n  local tResponse = http.get( \"http://pastebin.com/raw.php?i=\" .. textutils.urlEncode( sCode ) )\r\n  if tResponse then\r\n    local sResponse = tResponse.readAll()\r\n    tResponse.close()\r\n    \r\n    local handle = fs.open( sPath, \"w\" )\r\n    handle.write( sResponse )\r\n    handle.close()\r\n    return true\r\n  end\r\n  return false\r\nend\r\n```\r\n* Downloads sCode from pastebin as sFile\r\n* Returns: success _boolean_\r\n\r\n### pastebin.put( sFile )\r\n```Lua\r\nfunction put( sFile )\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  \r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.isDir( sPath ), \"Cannot upload directories\", 2 )\r\n  assert( not fs.exists( sPath ), \"File doesn't exist\", 2 )\r\n  \r\n  local sName = fs.getName( sPath )\r\n  local handle = fs.open( sPath, \"r\" )\r\n  local sText = handle.readAll()\r\n  handle.close()\r\n  local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\r\n  local response = http.post(\r\n    \"http://pastebin.com/api/api_post.php\", \r\n    \"api_option=paste&\" ..\r\n    \"api_dev_key=\" .. key .. \"&\" ..\r\n    \"api_paste_format=lua&\" ..\r\n    \"api_paste_name=\" .. textutils.urlEncode( sPath ) .. \"&\" ..\r\n    \"api_paste_code=\" .. textutils.urlEncode( sText )\r\n  )\r\n\r\n  if response then\r\n    local sResponse = response.readAll()\r\n    local sCode = string.match( sResponse, \"[^/]+$\" )\r\n    response.close()\r\n    return sCode, true\r\n  end\r\n  return nil, false\r\nend\r\n```\r\n* Uploads sFile to pastebin\r\n* Returns: code _string_, success _boolean_\r\n\r\n### pastebin.updateFile( sCode, sFile )\r\n```Lua\r\nfunction updateFile( sCode, sFile )\r\n  assert( type( sCode ) == \"string\", \"Number expected, got \" .. type( sCode ), 2)\r\n  assert( type( sFile ) == \"string\", \"String expected, got \" .. type( sFile ), 2)\r\n  \r\n  local sPath = shell.resolve( sFile )\r\n  assert( not fs.isDirectory( sPath ), \"Cannot update directory\", 2)\r\n  \r\n  local httpHandle = http.get( \"http://pastebin.com/raw.php?i=\" .. textutils.urlEncode( sCode ) )\r\n  if httpHandle then\r\n    local sResponse = httpHandle.readAll()\r\n    httpHandle.close()\r\n    \r\n    if sResponse and sResponse ~= \"\" then\r\n      local fileContent = \"[none&set]\"\r\n      if fs.exists( sPath ) then\r\n        local fileHandle = fs.open( sPath, \"r\" )\r\n        fileContent = fileHandle.readAll()\r\n        fileHandle.close()\r\n      end\r\n        \r\n      if fileContent ~= sResponse then\r\n        fileHandle = fs.open( sPath, \"w\" )\r\n        fileHandle.write( sResponse )\r\n        fileHandle.close()\r\n        return true\r\n      end\r\n    end\r\n    return false\r\nend\r\n```\r\n* Updates sFile using sCode from pastebin, if sFile is not the same as pastebin file\r\n* Returns: success _boolean_\r\n\r\n## String API\r\n### string.generate( nLength, nCharSet )\r\n```Lua\r\nfunction string.generate( nLength, nCharSet )\r\n  assert( type( nLength ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( nCharSet ) == \"number\", \"Number expected, got \" .. type( nCharSet ), 2)\r\n\tlocal nCharSet = nCharSet or 128\r\n\tlocal str = \"\"\r\n\tfor i = 1, nLength do\r\n\t\tstr = str .. math.random( 1, nCharSet ):char()\r\n\tend\r\n\treturn str\r\nend\r\n```\r\n* Generates a string of nLength with ASCII characters ranging from 0 to nCharSet\r\n* Returns: _string_\r\n\r\n### string.replaceChar( str, nPos, sReplace ) OR string:replaceChar( nPos, sReplace )\r\n```Lua\r\nfunction string:replaceChar( nPos, sReplace )\r\n  assert( type( nPos ) == \"number\", \"Number expected, got \" .. type( nLength ), 2)\r\n  assert( type( sReplace ) == \"string\", \"String expected, got \" .. type( nCharSet ), 2)\r\n  return self:sub( 1, nPos - 1 ) .. sReplace .. self:sub( nPos + 1 )\r\nend\r\n```\r\n* Replaces character at nPos in string with sReplace\r\n* Returns: _string_\r\n\r\n###string.safePattern()\r\n```Lua\r\nTo be completed\r\n```\r\n( Insert description here )\r\n\r\n###string.splitAtWhite( str )\r\n```Lua\r\nfunction string:splitAtWhite()\r\n\tlocal tData = {}\r\n\tfor sArg in self:gmatch( \"[^%s]+\" ) do\r\n\t\ttable.insert( tData, sArg )\r\n\tend\r\n\treturn tData\r\nend\r\n```\r\n* Splits str into seperate elements based on whitespace. Good for pulling arguments from a single string\r\n* Returns: _table_\r\n\r\n## Table API\r\n### table.sortLToG( tbl )\r\n```Lua\r\nfunction table.sortLToG( tbl )\r\n  assert( type( tbl ) == \"table\", \"Table expected, got \" .. type( tbl ), 2 )\r\n  table.sort( tbl, function( a, b ) return a < b end )\r\n  return tbl\r\nend\r\n```\r\n* Sorts tbl's elements from least to greatest( A - Z, 1 - 9, etc )\r\n* Returns: _table_\r\n\r\n### table.sortGToL( tbl )\r\n```Lua\r\nfunction table.sortGToL( tbl )\r\n  table.sort( tbl, function( a, b ) return a > b end )\r\n  return tbl\r\nend\r\n```\r\n* Sorts tbl's elements from greatest to least ( Z - A, 9 - 1, etc )\r\n* Returns: table\r\n\r\n## Term API\r\n### term.getCursorBlink()\r\n```Lua\r\nTo be completed\r\n```\r\n( Insert description here )\r\n\r\n### term.clear( nx, ny, nTextColour, nBackgroundColour )\r\n```Lua\r\nfunction term.clear( nx, ny, nTextColour, nBackgroundColour )\r\n  if nTextColour ~= nil then\r\n    assert( type( nTextColour ) == \"number\", \"Number expected, got \" .. type( nTextColour ), 2)\r\n    term.setTextColour( nTextColour )\r\n  end\r\n  if nBackgroundColour ~= nil then\r\n    assert( type( nBackgroundColour ) == \"number\", \"Number expected, got \" .. type( nBackgroundColour ), 2)\r\n    term.setBackgroundColour( nBackgroundColour )\r\n  end\r\n  if nx ~= nil then\r\n    assert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  end\r\n  if ny ~= nil then\r\n    assert( type( ny ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  end\r\n  term.setCursorPos( nx or currentX, ny or currentY )\r\n  oldTerm.clear()\r\n  local nMaxx,nMaxy = term.getSize()\r\n  -- Clear pixel data\r\n  for i = 1, nMaxx do\r\n    for j = 1, nMaxy do\r\n      tPixels[i..\" \"..j] = {\r\n        Character = \" \",\r\n        TextColor = nTextColour or term.getTextColour(),\r\n        TextColour = nTextColour or term.getTextColour(),\r\n        BackgroundColor = nBackgroundColour or term.getBackgroundColour(),\r\n        BackgroundColour = nBackgroundColour or term.getBackgroundColour()\r\n      }\r\n    end\r\n  end\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.reset()\r\n```Lua\r\nfunction term.reset()\r\n  term.setTextColour(colors.white)\r\n  term.setBackgroundColour(colors.black)\r\n  term.setCursorPos(1,1)\r\n  term.setCursorBlink(false)\r\n  term.clear()\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.getPixelData( nx, ny )\r\n```Lua\r\nfunction term.getPixelData( nx, ny )\r\n  assert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n  assert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n  return tPixels[ nx .. \" \" .. ny ]\r\nend\r\n```\r\n( Insert description here )\r\n\r\n### term.getTextColor()\r\n```Lua\r\nfunction term.getTextColor()\r\n  return currentTextColour\r\nend\r\n```\r\n* Returns the current terminal's text color\r\n* Returns: color _number_\r\n\r\n### term.getBackgroundColour()\r\n```Lua\r\nfunction term.getBackgroundColour()\r\n  return currentBackgroundColour\r\nend\r\n```\r\n* Returns the current terminal's background color\r\n* Returns: color _number_\r\n\r\n## Text API\r\n### text.bracket( sText, nx, ny, nTextColour, nBracketColour, nBackgroundColour )\r\n```Lua\r\nfunction bracket( sText, nx, ny, nTextColour, nBracketColour, nBackgroundColour )\r\n\tassert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n\tassert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n\tassert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n\r\n  if nTextColour then\r\n    assert( type( nTextColour ) == \"number\", \"Number/nil expected, got \" .. type( nTextColour ), 2)\r\n  end\r\n  if nBracketColour then\r\n    assert( type( nBracketColour ) == \"number\", \"Number/nil expected, got \" .. type( nBracketColour ), 2)\r\n  end\r\n  if nBackgroundColour then\r\n\t\tassert( type( nBackgroundColour ) == \"number\", \"Number/nil expected, got \" .. type( nBackgroundColour ), 2)\r\n    term.setBackgroundColour( nBackgroundColour )\r\n\tend\r\n  \r\n\tlocal xPos, yPos = term.getCursorPos()\r\n\tterm.setCursorPos( nx, ny )\r\n\tterm.setTextColour( nBracketColour or colours.white )\r\n\tterm.write( \"[\" .. string.rep(\" \", #sText) .. \"]\" )\r\n  \r\n\tterm.setTextColour( nTextColour or colours.white )\r\n  term.setCursorPos( nx + 1, ny )\r\n\tterm.write( sText )\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## text.center( sText, nx, ny )\r\n```Lua\r\nfunction center( sText, nx, ny )\r\n\tassert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n\tassert( type( nx ) == \"number\", \"Number expected, got \" .. type( nx ), 2)\r\n\tassert( type( ny ) == \"number\", \"Number expected, got \" .. type( ny ), 2)\r\n\tterm.setCursorPos( (( nx - #sText ) / 2) - 1, ny )\r\n\tterm.write( sText )\r\nend\r\n```\r\n( Insert description here )\r\n\r\n## text.printColorFormat( sText )\r\n```Lua\r\nfunction printColourFormat( sText )\r\n  assert( type( sText ) == \"string\", \"String expected, got \" .. type( sText ), 2)\r\n  local char200 = string.char( 200 )\r\n  \r\n  local storage = {}\r\n  local function matchLong( sMode1, sColour1, sMode2, sColour2 )\r\n    if (sMode1 == \"t\" and sMode2 == \"b\") or (sMode1 == \"b\" and sMode2 == \"t\") then\r\n      table.insert( storage, { \r\n        t = ( sMode1 == \"t\" and tonumber( sColour1 ) or tonumber( sColour2 ) ),\r\n        b = ( sMode1 == \"b\" and tonumber( sColour1 ) or tonumber( sColour2 ) )\r\n      } )\r\n    end\r\n    \r\n    if sMode1 == \"b\" and sMode2 == \"b\" then\r\n      table.insert( storage, { b = tonumber( sColour2 ) } )\r\n    elseif sMode1 == \"t\" and sMode2 == \"t\" then\r\n      table.insert( storage, { t = tonumber( sColour2 ) } )\r\n    end\r\n    return char200\r\n  end\r\n  \r\n  local function matchShort( sMode, sColour ) \r\n    return matchLong( sMode, sColour, sMode, sColour )\r\n  end\r\n  \r\n  -- Parse the text\r\n  local parsed = sText:gsub( \"%[([bt])%s*=%s*(%d-);%s*([bt])%s*=%s*(%d-)%]\", matchLong )\r\n  parsed = parsed:gsub( \"%[([bt])%s*=%s*(%d-)%]\", matchShort )\r\n  \r\n  -- Print it out on the terminal\r\n  local index = 1\r\n  local sMatch = \"[^\" .. char200 .. \"]+\"\r\n  for i = 1, #parsed do\r\n    local char = parsed:sub( i, i )\r\n    if storage[index] and char == char200 then\r\n      if storage[index].t then\r\n        term.setTextColour( 2 ^ storage[index].t )\r\n      end\r\n      if storage[index].b then\r\n        term.setBackgroundColour( 2 ^ storage[index].b )\r\n      end\r\n      index = index + 1\r\n    else\r\n       write( char )\r\n    end\r\n  end\r\nend\r\n```\r\n( Insert description here )","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}